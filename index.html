<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enzo Stabs</title>
    <style>
        /* CSS remains largely unchanged but moved to separate block below */
    </style>
</head>
<body>
<div id="gameOverScreen">
    <button id="restartButton">Try For More Hugs</button>
</div>
<div id="startMenu">
    <img src="guy.png" alt="Guy" class="guy">
    <h1>Enzo Stabs</h1>
    <p>Youâ€™re a brave Ronin navigating a twisted map,<br>hunted by Enzo, a relentless blue figure<br>with a bloody knife.</p>
    <p><strong>Controls:</strong><br>WASD - Move<br>Shift - Sprint (3s, 10s cooldown)<br>Mouse - Look around</p>
    <div>
        <label><input type="radio" name="difficulty" value="easy" checked> Easy</label>
        <label><input type="radio" name="difficulty" value="medium"> Medium</label>
        <label><input type="radio" name="difficulty" value="hard"> Hard</label>
    </div>
    <div>
        <label><input type="checkbox" id="musicToggle" checked> Music</label>
        <label><input type="checkbox" id="soundToggle" checked> Sound</label>
    </div>
    <input type="text" id="playerName" placeholder="Enter your name (3-25 chars)" maxlength="25">
    <button id="startButton" disabled>Gather Hugs</button>
    <img src="firey.gif" alt="Firey Left" class="firey left">
    <img src="firey.gif" alt="Firey Right" class="firey right">
</div>
<div id="hugOverlay">
    <img id="guyIndicator" src="guy.png" alt="Sprint Available">
    <img id="sprintIcon" src="fire-dash-green.png" alt="Sprint">
    <span>Hugs: 0</span>
    <img id="achievementSticker" src="stoned_dog.png" alt="Achievement">
    <img id="fireyBadge" src="firey.gif" alt="Firey Achievement">
</div>
<div id="alertOverlay">Enzo's Wrath Is Increasing!!!<br>Enzo's Teleport ability is active!</div>
<div id="vignette"></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/shaders/ColorCorrectionShader.js"></script>
<script>
    // JavaScript moved to separate blocks below
</script>
</body>
</html>

<style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #gameOverScreen {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(255, 0, 0, 0.7); display: none; justify-content: center; align-items: center;
        flex-direction: column; z-index: 10;
    }
    #restartButton {
        padding: 20px 40px; font-size: 24px; background: #fff; border: 2px solid #000; cursor: pointer;
    }
    #restartButton:hover { background: #ddd; }
    #startMenu {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0, 0, 0, 0.8); display: flex; justify-content: center; align-items: center;
        flex-direction: column; z-index: 15; color: #fff; font-family: Arial, sans-serif; text-align: center; font-size: 24px;
    }
    #startMenu button {
        padding: 15px 30px; font-size: 20px; background: #fff; border: 2px solid #000; cursor: pointer; margin-top: 20px;
    }
    #startMenu button:hover { background: #ddd; }
    #startMenu input[type="text"] { padding: 15px; font-size: 24px; margin-top: 20px; width: 400px; }
    #startMenu label { margin: 10px 10px 0 0; }
    #startMenu img.guy { width: 300px; height: 300px; margin-bottom: 20px; }
    #startMenu img.firey { width: 150px; height: 150px; position: absolute; bottom: 20px; }
    #startMenu img.firey.left { left: 20px; }
    #startMenu img.firey.right { right: 20px; }
    #hugOverlay {
        position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%);
        font-size: 48px; color: #fff; text-shadow: 2px 2px 4px #000; z-index: 5; display: flex; align-items: center;
    }
    #sprintIcon { width: 40px; height: 40px; margin-right: 20px; }
    #sprintIcon.rainbow {
        border: 3px solid; animation: rainbowBorder 2s infinite;
    }
    @keyframes rainbowBorder {
        0% { border-color: red; } 20% { border-color: orange; } 40% { border-color: yellow; }
        60% { border-color: green; } 80% { border-color: blue; } 100% { border-color: violet; }
    }
    #guyIndicator { width: 40px; height: 40px; margin-right: 10px; opacity: 0; transition: opacity 0.5s; }
    #guyIndicator.visible { opacity: 1; }
    #achievementSticker, #fireyBadge { width: 50px; height: 50px; margin-left: 20px; display: none; }
    .badge { width: 50px; height: 50px; margin-left: -40px; }
    #alertOverlay {
        position: fixed; left: 50%; transform: translateX(-50%); color: #ff0000;
        font-family: 'Courier New', monospace; font-size: 36px; text-align: center; display: none;
        z-index: 20; text-shadow: 2px 2px 0 #000; transition: top 6s linear;
    }
    #vignette {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
        background: radial-gradient(circle, transparent 40%, rgba(0, 0, 0, 0.7) 100%); z-index: 5;
    }
    .speechBubble {
        position: absolute; background: rgba(255, 255, 255, 0.9); border: 2px solid #000;
        border-radius: 10px; padding: 5px 10px; font-size: 14px; color: #000;
        font-family: Arial, sans-serif; z-index: 5; pointer-events: none; display: none;
    }
</style>

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

const composer = new THREE.EffectComposer(renderer);
const renderPass = new THREE.RenderPass(scene, camera);
composer.addPass(renderPass);
const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.8, 0.4, 0.9);
composer.addPass(bloomPass);
const colorCorrectionPass = new THREE.ShaderPass(THREE.ColorCorrectionShader);
colorCorrectionPass.uniforms['powRGB'].value = new THREE.Vector3(1.1, 1.1, 1.1);
colorCorrectionPass.uniforms['mulRGB'].value = new THREE.Vector3(1.05, 1.0, 0.95);
composer.addPass(colorCorrectionPass);

scene.fog = new THREE.Fog(0x333333, 10, 50);

const world = new CANNON.World();
world.gravity.set(0, -9.82, 0);

const textureLoader = new THREE.TextureLoader();

function setupLighting() {
const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
directionalLight.position.set(5, 10, 5);
directionalLight.castShadow = true;
scene.add(directionalLight);

const torchLight = new THREE.PointLight(0xffaa00, 1.5, 20);
torchLight.castShadow = true;
scene.add(torchLight);

return torchLight;
}
const torchLight = setupLighting();

const cellSize = 10;
const wallHeight = 5;
const map = [/* unchanged map array */];
const tiles = [/* unchanged tiles array */];

function setupEnvironment() {
// Floor
textureLoader.load('./floor.png', (texture) => {
const groundGeometry = new THREE.PlaneGeometry(200, 200);
const groundMaterial = new THREE.MeshStandardMaterial({ map: texture, roughness: 0.8 });
const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
groundMesh.rotation.x = -Math.PI / 2;
groundMesh.receiveShadow = true;
scene.add(groundMesh);
}, undefined, (error) => {
console.error('Failed to load floor.png:', error);
const groundGeometry = new THREE.PlaneGeometry(200, 200);
const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.8 });
const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
groundMesh.rotation.x = -Math.PI / 2;
groundMesh.receiveShadow = true;
scene.add(groundMesh);
});
const groundBody = new CANNON.Body({ mass: 0, shape: new CANNON.Plane() });
groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
world.addBody(groundBody);

// Decals
const decalGeometry = new THREE.CircleGeometry(1, 16);
const decalMaterial = new THREE.MeshBasicMaterial({ color: 0x666666, transparent: true, opacity: 0.5 });
const decals = new THREE.InstancedMesh(decalGeometry, decalMaterial, 50);
for (let i = 0; i < 50; i++) {
const matrix = new THREE.Matrix4();
matrix.setPosition(Math.random() * 190 - 95, 0.01, Math.random() * 190 - 95);
matrix.scale(new THREE.Vector3(Math.random() * 2 + 1, 1, Math.random() * 2 + 1));
decals.setMatrixAt(i, matrix);
}
scene.add(decals);

// Walls and Posters
let bambooWallTexture, enzosTexture;
const posterTextures = [];
const posterFiles = ['wallart.png', 'wallart1.png', 'wallart2.png'];
posterFiles.forEach(file => {
textureLoader.load(`assets/wallart/${file}`, (texture) => posterTextures.push(texture));
});

textureLoader.load('BambooWall.png', (texture) => {
bambooWallTexture = texture;
textureLoader.load('enzos.png', (texture) => {
enzosTexture = texture;
map.forEach((row, i) => {
row.forEach((cell, j) => {
if (cell === 1) {
const height = wallHeight + Math.random() * 2 - 1;
const isNearStart = Math.abs(i - 10) <= 2 && Math.abs(j - 10) <= 2;
const wallGeometry = new THREE.BoxGeometry(cellSize, height, cellSize);
const wallMaterial = (isNearStart || Math.random() < 0.2) ?
new THREE.MeshStandardMaterial({ map: enzosTexture, roughness: 0.5 }) :
new THREE.MeshStandardMaterial({ map: bambooWallTexture, roughness: 0.5 });
const wallMesh = new THREE.Mesh(wallGeometry, wallMaterial);
wallMesh.position.set(j * cellSize, height / 2, i * cellSize);
wallMesh.rotation.y = Math.random() * 0.1 - 0.05;
wallMesh.castShadow = true;
wallMesh.receiveShadow = true;
scene.add(wallMesh);

if (Math.random() < 0.2 && posterTextures.length > 0) {
const posterGeometry = new THREE.PlaneGeometry(2, 3);
const posterMaterial = new THREE.MeshBasicMaterial({
map: posterTextures[Math.floor(Math.random() * posterTextures.length)]
});
const posterMesh = new THREE.Mesh(posterGeometry, posterMaterial);
const face = Math.floor(Math.random() * 4);
const offset = cellSize / 2 - 0.1;
const yPos = Math.random() * (height - 3) + 1.5;
switch (face) {
case 0: posterMesh.position.set(j * cellSize, yPos, i * cellSize + offset); break;
case 1: posterMesh.position.set(j * cellSize, yPos, i * cellSize - offset); posterMesh.rotation.y = Math.PI; break;
case 2: posterMesh.position.set(j * cellSize - offset, yPos, i * cellSize); posterMesh.rotation.y = Math.PI / 2; break;
case 3: posterMesh.position.set(j * cellSize + offset, yPos, i * cellSize); posterMesh.rotation.y = -Math.PI / 2; break;
}
scene.add(posterMesh);
}

const wallBody = new CANNON.Body({
mass: 0,
shape: new CANNON.Box(new CANNON.Vec3(cellSize / 2, height / 2, cellSize / 2))
});
wallBody.position.set(j * cellSize, height / 2, i * cellSize);
world.addBody(wallBody);
}
});
});
});
});

// Tiles
textureLoader.load('stoned_chuck.png', (texture) => {
tiles.forEach((row, i) => {
row.forEach((tile, j) => {
if (tile === 1 && map[i][j] === 0) {
const tileGeometry = new THREE.PlaneGeometry(cellSize * 0.8, cellSize * 0.8);
const tileMaterial = new THREE.MeshBasicMaterial({ map: texture });
const tileMesh = new THREE.Mesh(tileGeometry, tileMaterial);
tileMesh.rotation.x = -Math.PI / 2;
tileMesh.position.set(j * cellSize + cellSize / 2, 0.01, i * cellSize + cellSize / 2);
scene.add(tileMesh);
} else if (tile === 2) {
const tileGeometry = new THREE.PlaneGeometry(cellSize, cellSize);
const tileMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
const tileMesh = new THREE.Mesh(tileGeometry, tileMaterial);
tileMesh.rotation.x = -Math.PI / 2;
tileMesh.position.set(j * cellSize + cellSize / 2, 0.01, i * cellSize + cellSize / 2);
scene.add(tileMesh);
}
});
});
});

// Decorative Objects
const torusMesh = new THREE.Mesh(
new THREE.TorusGeometry(2, 1, 16, 100),
new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.5 })
);
torusMesh.position.set(15, 1, 15);
torusMesh.castShadow = true;
torusMesh.receiveShadow = true;
scene.add(torusMesh);

const pyramidMesh = new THREE.Mesh(
new THREE.ConeGeometry(2, 4, 4),
new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.5 })
);
pyramidMesh.position.set(35, 2, 35);
pyramidMesh.castShadow = true;
pyramidMesh.receiveShadow = true;
scene.add(pyramidMesh);
}
setupEnvironment();

const audioContext = new (window.AudioContext || window.webkitAudioContext)();
const audioFiles = {
ambient: createAmbientSound(),
gameOver: new Audio('fuck-you-pay-me.mp3'),
hug: new Audio('hug.mp3'),
wrath: new Audio('coming-for-you.mp3'),
heartbeat: new Audio('heartbeat.mp3'),
splash: new Audio('splash.mp3')
};
audioFiles.heartbeat.loop = true;
audioFiles.splash.loop = true;
Object.values(audioFiles).forEach(audio => audio.preload = 'auto');

function createAmbientSound() {
const buffer = audioContext.createBuffer(2, audioContext.sampleRate * 10, audioContext.sampleRate);
for (let channel = 0; channel < 2; channel++) {
const data = buffer.getChannelData(channel);
for (let i = 0; i < data.length; i++) data[i] = (Math.random() - 0.5) * 0.05;
}
const source = audioContext.createBufferSource();
source.buffer = buffer;
source.loop = true;
const gain = audioContext.createGain();
gain.gain.value = 0.1;
source.connect(gain);
gain.connect(audioContext.destination);
return source;
}

function startAudio() {
if (audioContext.state === 'suspended') audioContext.resume();
if (document.getElementById('musicToggle').checked) {
if (!audioFiles.ambient.started) {
audioFiles.ambient.start();
audioFiles.ambient.started = true;
}
audioFiles.splash.play();
}
}

function playSound(sound, isMusic = false) {
const musicOn = document.getElementById('musicToggle').checked;
const soundOn = document.getElementById('soundToggle').checked;
if ((isMusic && musicOn) || (!isMusic && soundOn)) sound.play();
}

function stopSound(sound) {
sound.pause();
sound.currentTime = 0;
}

function tileSound() {
if (audioContext.state === 'running' && document.getElementById('soundToggle').checked) {
const oscillator = audioContext.createOscillator();
const gainNode = audioContext.createGain();
oscillator.type = 'square';
oscillator.frequency.setValueAtTime(220, audioContext.currentTime);
gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
oscillator.connect(gainNode);
gainNode.connect(audioContext.destination);
oscillator.start();
oscillator.stop(audioContext.currentTime + 0.1);
}
}

document.getElementById('musicToggle').addEventListener('change', (e) => {
if (e.target.checked) {
if (!audioFiles.ambient.started) {
audioFiles.ambient.start();
audioFiles.ambient.started = true;
}
playSound(audioFiles.splash, true);
} else {
stopSound(audioFiles.splash);
audioFiles.ambient.stop();
audioFiles.ambient = createAmbientSound();
}
});

document.getElementById('soundToggle').addEventListener('change', (e) => {
if (!e.target.checked) {
stopSound(audioFiles.gameOver);
stopSound(audioFiles.hug);
stopSound(audioFiles.wrath);
stopSound(audioFiles.heartbeat);
}
});

const waypoints = [];
map.forEach((row, i) => row.forEach((cell, j) => {
if (cell === 0) waypoints.push({ x: j * cellSize + cellSize / 2, z: i * cellSize + cellSize / 2 });
}));

function getClosestWaypoint(pos) {
return waypoints.reduce((closest, wp) => {
const dist = Math.hypot(wp.x - pos.x, wp.z - pos.z);
return dist < Math.hypot(closest.x - pos.x, closest.z - pos.z) ? wp : closest;
}, waypoints[0]);
}

function getNextWaypoint(currentPos, targetPos) {
const currentWp = getClosestWaypoint(currentPos);
const targetWp = getClosestWaypoint(targetPos);
if (currentWp === targetWp) return targetPos;
let minDist = Infinity;
let nextWp = currentWp;
waypoints.forEach(wp => {
if (wp === currentWp) return;
const distToTarget = Math.hypot(wp.x - targetWp.x, wp.z - targetWp.z);
const distToCurrent = Math.hypot(wp.x - currentWp.x, wp.z - currentWp.z);
if (distToTarget < minDist && distToCurrent < cellSize * 2) {
minDist = distToTarget;
nextWp = wp;
}
});
return nextWp;
}

function computeSteering(enzoPos, targetPos) {
const desired = new THREE.Vector3(targetPos.x - enzoPos.x, 0, targetPos.z - enzoPos.z).normalize();
let avoidance = new THREE.Vector3(0, 0, 0);
map.forEach((row, i) => {
row.forEach((cell, j) => {
if (cell === 1) {
const wallPos = new THREE.Vector3(j * cellSize + cellSize / 2, 0, i * cellSize + cellSize / 2);
const ahead = new THREE.Vector3(enzoPos.x, 0, enzoPos.z).add(desired.clone().multiplyScalar(5));
const toWall = wallPos.clone().sub(ahead);
const distToWall = toWall.length();
if (distToWall < 3) avoidance.sub(toWall.normalize().multiplyScalar((3 - distToWall) / 3));
}
});
});
return desired.add(avoidance).normalize();
}

function preventWallClipping(pos) {
const cellX = Math.floor(pos.x / cellSize);
const cellZ = Math.floor(pos.z / cellSize);
if (cellX >= 0 && cellX < 20 && cellZ >= 0 && cellZ < 20 && map[cellZ][cellX] === 1) {
const closestWp = getClosestWaypoint(pos);
pos.x = closestWp.x;
pos.z = closestWp.z;
}
return pos;
}

function findValidSpawn(roninPos, minDist, maxDist) {
const validSpawns = waypoints.filter(wp => {
const dist = Math.hypot(wp.x - roninPos.x, wp.z - roninPos.z);
return dist >= minDist && dist <= maxDist;
});
return validSpawns[Math.floor(Math.random() * validSpawns.length)];
}

function findValidTeleport(roninPos, minDist) {
const validSpawns = waypoints.filter(wp => {
const dist = Math.hypot(wp.x - roninPos.x, wp.z - roninPos.z);
return dist >= minDist;
});
return validSpawns[Math.floor(Math.random() * validSpawns.length)];
}

function setupEntities(callback) {
let playerHeadTexture, enzoHeadTexture, happEnzoTexture;

const roninGroup = new THREE.Group();
const roninBody = new CANNON.Body({ mass: 1, shape: new CANNON.Cylinder(0.5, 0.5, 2, 16) });
roninBody.position.set(10, 1, 10);
world.addBody(roninBody);

const enzoGroup = new THREE.Group();
const enzoBody = new CANNON.Body({ mass: 0, shape: new CANNON.Cylinder(0.25, 0.25, 1.5, 16) });
const enzoSpawn = findValidSpawn({ x: 10, z: 10 }, 20, 30);
enzoBody.position.set(enzoSpawn.x, 0.75, enzoSpawn.z);
world.addBody(enzoBody);

const hugs = [];
const compliments = [
"loves how <name> writes amazing code!",
    "admires <name>'s coding skills!",
        "thinks <name>'s code is pure art!",
            "is in awe of <name>'s programming!",
                "adores <name>'s brilliant code!"
                    ];

                    textureLoader.load('stoned_chuck.png', (texture) => {
                    playerHeadTexture = texture;
                    textureLoader.load('angry_enzo.png', (texture) => {
                    enzoHeadTexture = texture;
                    textureLoader.load('happ_enzo.png', (texture) => {
                    happEnzoTexture = texture;

                    // Ronin Setup
                    const roninBodyMesh = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.2, 0.2, 1.5, 16),
                    new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.5 })
                    );
                    roninBodyMesh.position.set(0, 0.75, 0);
                    roninBodyMesh.castShadow = true;
                    roninGroup.add(roninBodyMesh);
                    const roninHeadMesh = new THREE.Mesh(
                    new THREE.SphereGeometry(0.5, 32, 32),
                    new THREE.MeshStandardMaterial({ map: playerHeadTexture, roughness: 0.5 })
                    );
                    roninHeadMesh.position.set(0, 1.75, 0);
                    roninHeadMesh.castShadow = true;
                    roninGroup.add(roninHeadMesh);
                    const armMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.5 });
                    const leftArm = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 1, 16), armMaterial);
                    leftArm.position.set(-0.5, 1.25, 0);
                    leftArm.castShadow = true;
                    roninGroup.add(leftArm);
                    const rightArm = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 1, 16), armMaterial);
                    rightArm.position.set(0.5, 1.25, 0);
                    rightArm.castShadow = true;
                    roninGroup.add(rightArm);
                    const legMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.5 });
                    const leftLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 1, 16), legMaterial);
                    leftLeg.position.set(-0.2, 0.25, 0);
                    leftLeg.castShadow = true;
                    roninGroup.add(leftLeg);
                    const rightLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 1, 16), legMaterial);
                    rightLeg.position.set(0.2, 0.25, 0);
                    rightLeg.castShadow = true;
                    roninGroup.add(rightLeg);
                    scene.add(roninGroup);
                    roninGroup.visible = false;

                    // Enzo Setup
                    const enzoTorsoMesh = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.3, 1, 16, 1, true),
                    new THREE.MeshStandardMaterial({ color: 0x0000ff, roughness: 0.5 })
                    );
                    enzoTorsoMesh.position.set(0, 0.5, 0);
                    enzoTorsoMesh.castShadow = true;
                    enzoGroup.add(enzoTorsoMesh);
                    const enzoHeadMesh = new THREE.Mesh(
                    new THREE.BoxGeometry(1, 1, 1),
                    new THREE.MeshStandardMaterial({ map: enzoHeadTexture, roughness: 0.5 })
                    );
                    enzoHeadMesh.position.set(0, 1.5, 0);
                    enzoHeadMesh.castShadow = true;
                    enzoGroup.add(enzoHeadMesh);
                    const enzoArmMaterial = new THREE.MeshStandardMaterial({ color: 0x0000ff, roughness: 0.5 });
                    const enzoLeftArm = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 1.5, 16), enzoArmMaterial);
                    enzoLeftArm.position.set(-0.5, 0.5, 0);
                    enzoLeftArm.rotation.z = Math.PI / 4;
                    enzoLeftArm.castShadow = true;
                    enzoGroup.add(enzoLeftArm);
                    const enzoRightArm = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 1.5, 16), enzoArmMaterial);
                    enzoRightArm.position.set(0.5, 0.5, 0);
                    enzoRightArm.rotation.z = -Math.PI / 4;
                    enzoRightArm.castShadow = true;
                    enzoGroup.add(enzoRightArm);
                    const knifeMesh = new THREE.Mesh(
                    new THREE.BoxGeometry(0.1, 1.5, 0.05),
                    new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 0.8, roughness: 0.2 })
                    );
                    knifeMesh.position.set(0, 0.75, 0);
                    knifeMesh.rotation.x = Math.PI / 2;
                    knifeMesh.castShadow = true;
                    enzoRightArm.add(knifeMesh);
                    const knifeTipMesh = new THREE.Mesh(
                    new THREE.BoxGeometry(0.1, 0.2, 0.05),
                    new THREE.MeshStandardMaterial({ color: 0xff0000 })
                    );
                    knifeTipMesh.position.set(0, 0.85, 0);
                    knifeTipMesh.castShadow = true;
                    enzoRightArm.add(knifeTipMesh);
                    const bloodMesh = new THREE.Mesh(
                    new THREE.SphereGeometry(0.05, 8, 8),
                    new THREE.MeshBasicMaterial({ color: 0xff0000 })
                    );
                    bloodMesh.position.set(0, 0.85, 0);
                    bloodMesh.visible = false;
                    enzoRightArm.add(bloodMesh);
                    const enzoLegMaterial = new THREE.MeshStandardMaterial({ color: 0x0000ff, roughness: 0.5 });
                    const enzoLeftLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 1, 16), enzoLegMaterial);
                    enzoLeftLeg.position.set(-0.2, 0.25, 0);
                    enzoLeftLeg.castShadow = true;
                    enzoGroup.add(enzoLeftLeg);
                    const enzoRightLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 1, 16), enzoLegMaterial);
                    enzoRightLeg.position.set(0.2, 0.25, 0);
                    enzoRightLeg.castShadow = true;
                    enzoGroup.add(enzoRightLeg);
                    scene.add(enzoGroup);

                    // Hugs Setup
                    for (let i = 0; i < 20; i++) {
                    const pos = waypoints[Math.floor(Math.random() * waypoints.length)];
                    const hugGroup = new THREE.Group();
                    const hugTorsoMesh = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.3, 1, 16, 1, true),
                    new THREE.MeshStandardMaterial({ color: 0xffff00, roughness: 0.5, emissive: 0xffff00, emissiveIntensity: 0.5 })
                    );
                    hugTorsoMesh.position.set(0, 0.5, 0);
                    hugTorsoMesh.castShadow = true;
                    hugGroup.add(hugTorsoMesh);
                    const hugHeadMesh = new THREE.Mesh(
                    new THREE.BoxGeometry(1, 1, 1),
                    new THREE.MeshStandardMaterial({ map: happEnzoTexture, roughness: 0.5 })
                    );
                    hugHeadMesh.position.set(0, 1.5, 0);
                    hugHeadMesh.castShadow = true;
                    hugGroup.add(hugHeadMesh);
                    const hugArmMaterial = new THREE.MeshStandardMaterial({ color: 0xffff00, roughness: 0.5 });
                    const hugLeftArm = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 1.5, 16), hugArmMaterial);
                    hugLeftArm.position.set(-0.5, 0.5, 0);
                    hugLeftArm.castShadow = true;
                    hugGroup.add(hugLeftArm);
                    const hugRightArm = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 1.5, 16), hugArmMaterial);
                    hugRightArm.position.set(0.5, 0.5, 0);
                    hugRightArm.castShadow = true;
                    hugGroup.add(hugRightArm);
                    const hugLegMaterial = new THREE.MeshStandardMaterial({ color: 0xffff00, roughness: 0.5 });
                    const hugLeftLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 1, 16), hugLegMaterial);
                    hugLeftLeg.position.set(-0.2, 0.25, 0);
                    hugLeftLeg.castShadow = true;
                    hugGroup.add(hugLeftLeg);
                    const hugRightLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 1, 16), hugLegMaterial);
                    hugRightLeg.position.set(0.2, 0.25, 0);
                    hugRightLeg.castShadow = true;
                    hugGroup.add(hugRightLeg);
                    hugGroup.position.set(pos.x, 0, pos.z);
                    scene.add(hugGroup);

                    const hugBody = new CANNON.Body({
                    mass: 1,
                    shape: new CANNON.Cylinder(0.25, 0.25, 1.5, 16)
                    });
                    hugBody.position.set(pos.x, 0.75, pos.z);
                    world.addBody(hugBody);

                    const speechBubble = document.createElement('div');
                    speechBubble.className = 'speechBubble';
                    const playerName = document.getElementById('playerName').value || "Ronin";
                    speechBubble.textContent = compliments[Math.floor(Math.random() * compliments.length)].replace('<name>', playerName);
                        document.body.appendChild(speechBubble);

                        hugs.push({
                        group: hugGroup,
                        body: hugBody,
                        collected: false,
                        leftArm: hugLeftArm,
                        rightArm: hugRightArm,
                        leftLeg: hugLeftLeg,
                        rightLeg: hugRightLeg,
                        speechBubble,
                        speechTimer: Math.random() * 5
                        });
                        }

                        callback({
                        ronin: { group: roninGroup, body: roninBody, leftArm, rightArm, leftLeg, rightLeg },
                        enzo: { group: enzoGroup, body: enzoBody, head: enzoHeadMesh, torso: enzoTorsoMesh, leftArm: enzoLeftArm, rightArm: enzoRightArm, leftLeg: enzoLeftLeg, rightLeg: enzoRightLeg, bloodMesh },
                        hugs
                        });
                        });
                        });
                        });
                        }

                        const sprintParticles = new THREE.Points(
                        new THREE.BufferGeometry(),
                        new THREE.PointsMaterial({ size: 0.3, vertexColors: true, transparent: true })
                        );
                        scene.add(sprintParticles);

                        const hugParticles = new THREE.Points(
                        new THREE.BufferGeometry(),
                        new THREE.PointsMaterial({ size: 0.5, color: 0xffff00, transparent: true, opacity: 1 })
                        );
                        scene.add(hugParticles);
                        let hugParticleData = [];

                        const bloodParticles = new THREE.Points(
                        new THREE.BufferGeometry(),
                        new THREE.PointsMaterial({ size: 0.1, color: 0xff0000, transparent: true, opacity: 1 })
                        );
                        scene.add(bloodParticles);
                        let bloodParticleData = [];

                        function updateSprintParticles(roninPos, sprintActive) {
                        if (sprintActive) {
                        const positions = new Float32Array(50 * 3);
                        const colors = new Float32Array(50 * 3);
                        for (let i = 0; i < 50; i++) {
                        positions[i * 3] = roninPos.x + (Math.random() - 0.5) * 0.5;
                        positions[i * 3 + 1] = roninPos.y + Math.random() * 0.5;
                        positions[i * 3 + 2] = roninPos.z + (Math.random() - 0.5) * 0.5;
                        const t = i / 50;
                        colors[i * 3] = 1.0 - t * 0.5;
                        colors[i * 3 + 1] = t * 0.5;
                        colors[i * 3 + 2] = 0;
                        }
                        sprintParticles.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                        sprintParticles.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                        } else {
                        sprintParticles.geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(0), 3));
                        }
                        }

                        function updateHugParticles(time) {
                        hugParticleData = hugParticleData.filter(p => p.life > 0);
                        const positions = new Float32Array(hugParticleData.length * 3);
                        for (let i = 0; i < hugParticleData.length; i++) {
                        const p = hugParticleData[i];
                        p.position.add(p.velocity);
                        p.velocity.y -= 0.05;
                        p.life -= 0.02;
                        p.position.y += Math.sin(time + i) * 0.1;
                        positions[i * 3] = p.position.x;
                        positions[i * 3 + 1] = p.position.y;
                        positions[i * 3 + 2] = p.position.z;
                        }
                        hugParticles.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                        hugParticles.material.opacity = Math.max(0, hugParticleData.length > 0 ? hugParticleData[0].life : 0);
                        }

                        function updateBloodParticles() {
                        bloodParticleData = bloodParticleData.filter(p => p.life > 0);
                        const positions = new Float32Array(bloodParticleData.length * 3);
                        for (let i = 0; i < bloodParticleData.length; i++) {
                        const p = bloodParticleData[i];
                        p.position.add(p.velocity);
                        p.velocity.y -= 0.05;
                        p.life -= 0.02;
                        positions[i * 3] = p.position.x;
                        positions[i * 3 + 1] = p.position.y;
                        positions[i * 3 + 2] = p.position.z;
                        }
                        bloodParticles.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                        bloodParticles.material.opacity = Math.max(0, bloodParticleData.length > 0 ? bloodParticleData[0].life : 0);
                        }
                        
                        